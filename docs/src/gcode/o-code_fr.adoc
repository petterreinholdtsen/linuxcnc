:lang: fr
:toc:

[[cha:O-codes]]
= Les O-codes(((O-codes)))

// Custom lang highlight
// must come after the doc title, to work around a bug in asciidoc 8.6.6
:ini: {basebackend@docbook:'':ini}
:hal: {basebackend@docbook:'':hal}
:ngc: {basebackend@docbook:'':ngc}

== Utilisation des O-codes

Les O-codes permettent le contrôle de flux dans les programmes NGC.
Ils commencent par une lettre *O*, qu'il ne faut pas confondre avec le
chiffre *0*. Chaque bloc est associé à une adresse, qui est la valeur utilisée
après la lettre *O*. Il faut prendre soin de bien faire correspondre les adresses des O-codes.

== Numbering

Numbered O codes must have a unique number for each subroutine,

.Exemple de numérotation
----
(the start of o100)
o100 sub
(noter que les blocs if - endif utilisent des numéros différents)
  (the start of o110)
  o110 if [#2 GT 5]
    (some code here)
  (the end of o110)
  o110 endif
  (some more code here)
(the end of o100)
o100 endsub
----

[[ocode:comments]]
== Comments(((Comments)))

Comments on the same line as the O word should not be used as the behavior can
change in the future.

Le comportement est indéfini si:

* Le même nombre est utilisé pour plusieurs blocs
* D'autres mots sont utilisés sur une ligne contenant un mot O-.
* Un commentaire est utilisé sur une ligne contenant un mot O-.

[NOTE]
L'utilisation de la lettre *o* minuscule facilite la distinction avec le
chiffre *0* qui peut être tapé par erreur. Par exemple: +
*+o100+* est plus facile à distinguer de *+0100+* que *+O100+*.

[[sec:Sous-programmes]]
== Sous-programmes: *sub*, *endsub*, *return*, *call*(((Sous-programmes)))

Les sous-programmes s'étendent d'un 'O- sub' à un 'O- endsub'. Les lignes, à l'intérieur du sous-programme (le corps du
sous-programme), ne sont pas exécutées dans l'ordre, mais
elles sont exécutées à chaque fois que le sous-programme est appelé avec un 'O-call'.

.Exemple de sous-programme
----
o100 sub
  G53 G0 X0 Y0 Z0 (rapid move to machine home)
o100 endsub

(the subroutine is called)
o100 call
M2
----

Pour plus de détails sur ces instructions voir: <<sec:G53-Mouvement-Coordonnees-Absolues,mouvement G53>>, <<sec:G0,mouvement rapide G0>>, and <<sec:M2-M30,fin de programme M2>>.

.O- return
À l'intérieur d'un sous-programme, 'O- return' peut être exécuté,
pour retourner immédiatement au code appelant, comme si 'O- endsub' avait été rencontré.

.Exemple avec 'O- return'
----
o100 sub
  (test if parameter #2 is greater than 5)
  o110 if [#2 GT 5]
    (return to top of subroutine if test is true)
    o100 return
  o110 endif
    (this only gets executed if parameter #2 is not greater than 5)
    (DEBUG, parameter 1 is [#1])
o100 endsub
----

Voir également les sections: <<sec:Operateurs-Binaires,opérateurs binaires>> and <<sec:parametres,paramètres>>.

.O- call
'O- call' peut prendre jusqu'à 30 arguments optionnels, qui sont
passés au sous-programme comme '#1', '#2' , ..., '#N'. Les paramètres de '#N+1' à
'#30' ont la même valeur dans le contexte de l'appel.
Au retour du sous-programme, les valeurs des
paramètres #1 jusqu'à #30 (quel que soit le nombre d'arguments) sont
restaurés aux valeurs qu'ils avaient
avant l'appel.

Parce que '1 2 3' est analysé comme le nombre 123, les paramètres
doivent être placés entre crochets. L'appel de sous-programme suivant, s'effectue avec 3 arguments:

.Exemple d'appel 'O-'
----
o100 sub
  (test if parameter #2 is greater than 5)
  o110 if [#2 GT 5]
    (return to top of subroutine if test is true)
    o100 return
  o110 endif
    (this only gets executed if parameter #2 is not greater than 5)
    (DEBUG, parameter 1 is [#1])
    (DEBUG, parameter 3 is [#3])
o100 endsub

o100 call [100] [2] [325]
----

Les corps de sous-programme ne peuvent pas être imbriqués. Ils ne
peuvent être appelés qu'après avoir été définis. Ils peuvent être
appelés depuis d'autres fonctions et peuvent s'appeler eux même
récursivement, s'il est judicieux de le faire. Le niveau maximum d'imbrication des sous-programmes est de 10.

Les sous-programmes n'ont pas de 'valeur de retour', mais ils peuvent
changer la valeur des paramètres au dessus de #30 et ces changements
sont visibles depuis le code appelant. Les sous-programmes peuvent aussi changer la valeur des paramètres nommés globaux.

[[ocode:fanuc-style-programs]]
=== Fanuc-Style Numbered Programs(((Subroutines,M98,M99)))

Numbered programs (both main and subprograms), the 'M98' call and
'M99' return M-codes, and their respective semantic differences are an
alternative to the rs274ngc subroutines described above, provided for
compatibility with Fanuc and other machine controllers.

Numbered programs are enabled by default, and may be disabled by
placing `DISABLE_FANUC_STYLE_SUB = 1` in the `[RS274NGC]` section of the `.ini` file.

[NOTE]
Numbered main and subprogram definitions and calls differ from
traditional rs274ngc both in syntax and execution.  To reduce the
possibility of confusion, the interpreter will raise an error if
definitions of one style are mixed with calls of another.

.Numbered Subprogram Simple Example
[source,{ngc}]
----
o1 (Example 1)    ; Main program 1, "Example 1"
M98 P100          ; Call subprogram 100
M30               ; End main program

o100              ; Beginning of subprogram 100
  G53 G0 X0 Y0 Z0 ; Rapid move to machine home
M99               ; Return from subprogram 100
----

.'o1 (Title)'
The optional main program beginning block gives the main program the
number `1`.  Some controllers treat an optional following
parenthesized comment as a program title, `Example 1` in this example,
but this has no special meaning in the rs274ngc interpreter.

.'M98 P- <L\->'
Call a numbered subprogram.  The block `M98 P100` is analogous to the
traditional `o100 call` syntax, but may only be used to call a
following numbered subprogram defined with `o100`...`M99`.  An
optional 'L'-word specifies a loop count.

.'M30'
The main program must be terminated with `M02` or `M30` (or `M99`; see
below).

.'O-' subprogram definition start
Marks the start of a numbered subprogram definition.  The block `O100`
is similar to `o100 sub`, except that it must be placed later in the
file than the `M98 P100` calling block.

.'M99' return from numbered subroutine
The block `M99` is analogous to the traditional `o100 endsub` syntax,
but may only terminate a numbered program (`o100` in this example),
and may not terminate a subroutine beginning with the `o100 sub`
syntax.

The `M98` subprogram call differs from rs274ngc `O call` in the
following ways:

* The numbered subprogram must follow the `M98` call in the program file.
  The interpreter will throw an error if the subprogram precedes the call block.
* Parameters `#1`, `#2`, ..., `#30` are global and accessible in
  numbered subprograms, similar to higher-numbered parameters in
  traditional style calls.  Modifications to these parameters within
  a subprogram are global modifications, and will be persist after
  subprogram return.
* `M98` subprogram calls have no return value.
* `M98` subprogram call blocks may contain an optional L-word
  specifying a loop repeat count.  Without the L-word, the subprogram
  will execute once only (equivalent to `M98 L1`).  An `M98 L0` block will not execute the subprogram.

In rare cases, the `M99` M-code may be used to terminate the main
program, where it indicates an 'endless program'.  When the
interpreter reaches an `M99` in the main program, it will skip back to
the beginning of the file and resume execution at the first line.  An
example use of an endless program is in a machine warm-up cycle; a
block delete program end `/M30` block might be used to stop the cycle
at a tidy point when the operator is ready.

.Numbered Subprogram Full Example
[source,{ngc}]
----
O1                             ; Main program 1
  #1 = 0
  (PRINT,X MAIN BEGIN:  1=#1)
  M98 P100 L5                  ; Call subprogram 100
  (PRINT,X MAIN END:  1=#1)
M30                            ; End main program

O100                           ; Subprogram 100
  #1 = [#1 + 1]
  M98 P200 L5                  ; Call subprogram 200
  (PRINT,>> O100:  #1)
M99                            ; Return from Subprogram 100

O200                           ; Subprogram 200
  #1 = [#1 + 0.01]
  (PRINT,>>>> O200:  #1)
M99                            ; Return from Subprogram 200
----

In this example, parameter `#1` is initialized to `0`.  Subprogram
`O100` is called five times in a loop.  Nested within each call to
`O100`, subprogram `O200` is called five times in a loop, for 25 times
total.

Note that parameter `#1` is global.  At the end of the main program,
after updates within `O100` and `O200`, its value will equal `5.25`.

[[sec:Boucles]]
== Boucles: *do*, *while*, *endwhile*, *break*, *continue*(((Boucles)))(((do)))(((while)))(((endwhile)))(((break)))(((continue)))

La boucle 'while' a deux structures possibles: 'while - endwhile' et 'do - while'.
Dans chaque cas, la boucle est quittée quand la condition du 'while' devient
fausse. La différence se trouve en fin de test de la condition. La boucle
'do - while' exécute le code dans la boucle puis test la condition.
La boucle 'while - endwhile' effectue le test d'abord.

.Exemple avec 'while - endwhile'
----
(dessine la forme d'une dent de scie)
G0 X1 Y0 (déplacement en position de départ)
#1 = 1 (assigne la valeur 1 au paramètre #1)
F25 (fixe la vitesse d'avance travail)
o101 while [#1 LT 10]
  G1 X0
  G1 Y[#1/10] X1
  #1 = [#1+1] (incrémente le compteur de test)
o101 endwhile
M2 (fin de programme)
----

.Exemple avec 'do - while'
----
#1 = 0 (assigne la valeur 0 au paramètre #1)
o100 do
  (debug, paramètre 1 = #1)
  o110 if [#1 EQ 2]
    #1 = 3 (assigne la valeur 3 au paramètre #1)
    (msg, #1 s'est vu assigné la valeur 3)
    o100 continue (saute au début de la boucle)
  o110 endif
  (le code d'usinage ici)
  #1 = [#1 + 1] (incrémente le compteur de test)
o100 while [#1 LT 3]
(msg, boucle terminée)
M2
----

À l'intérieur d'une boucle while, 'O- break', quitte immédiatement
la boucle et 'O- continue', saute immédiatement à la prochaine
évaluation de la condition du 'while'. Si elle est vraie, la boucle
recommence au début. Si elle est fausse, la boucle est quittée.

[[sec:Conditionnels]]
== Conditionnels(((Conditionnels)))

Le 'if' conditionnel exécute un groupe d'instructions avec le même nombre 'O'
qui commence avec 'if' et se termine avec 'endif'. Les conditions optionnelles
'elseif' et 'else' peuvent se trouver entre le 'if' et le 'endif'.

Si la condition du 'if' est vraie, les instructions qui suivent le 'if' seront
exécutées jusqu'à, au maximum, l'instruction conditionnelle suivante.

Si la condition du 'if' est fausse, alors les instructions conditionnelles
'elseif' suivantes seront évaluées l'une après l'autre. Si la condition du
'elseif' est vraie alors les instructions suivant ce 'elseif' seront exécutées
jusqu'à l'instruction conditionnelle suivante. Si aucune des conditions du 'if'
ou du 'elseif' n'est vraie, alors les instructions suivant le 'else' seront
exécutées. Quand une condition est vraie, les autres instructions conditionnelles du groupe ne sont plus évaluées.

.Exemple avec 'if - endif'
----
(if parameter #31 is equal to 3 set S2000)
o101 if [#31 EQ 3]
  S2000
o101 endif
----

.Exemple avec 'if - elseif - else - endif'
----
(if parameter #2 is greater than 5 set F100)
o102 if [#2 GT 5]
  F100
o102 elseif [#2 LT 2]
(else if parameter #2 is less than 2 set F200)
  F200
(else if parameter #2 is 2 through 5 set F150)
o102 else
  F150
o102 endif
----

Several conditions may be tested for by 'elseif' statements until the
'else' path is finally executed if all preceding conditions are false:

.If Elseif Else Endif Example
----
(if parameter #2 is greater than 5 set F100)
O102 if [#2 GT 5]
  F100
(else if parameter #2 less than 2 set F200)
O102 elseif [#2 LT 2]
  F20
(parameter #2 is between 2 and 5)
O102 else
  F200
O102 endif
----

[[sec:Repetitions]]
== Répétition: *Repeat*(((Repeat)))

La répétition 'repeat', exécutera les blocs contenus entre 'repeat' et
'endrepeat' le nombre de fois spécifié entre crochets. L'exemple
suivant montre comment usiner une séries de 5 formes diagonales
commençant à la position courante.

.Exemple avec 'repeat'
----
(Usine 5 formes diagonales)
G91 (Mode incrémental)
O103 repeat [5]
... (insérer le code d'usinage ici)
G0 X1 Y1 (Mouvement en diagonale vers la position suivante)
O103 endrepeat
G90 (Mode absolu)
----

[[ocode:indirection]]
== Indirection(((Indirection)))

L'adresse de O- peut être donnée par un paramètre ou un calcul.

.Exemple d'indirection
----
O[#101+2] call
----

.Calcul des valeurs dans les O-codes
Voici un condensé des sections utiles aux calculs des O-codes:

* <<sec:parametres,les paramètres>>,
* <<sec:Expressions,les expressions>>,
* <<sec:Operateurs-Binaires,les opérateurs binaires>>,
* <<sec:Fonctions,les fonctions>>.

[[ocode:calling-files]]
== Appel de fichier(((Appel de fichier)))

Pour appeler un sous-programme par son nom, ce sous-programme doit contenir
un 'sub' et un 'endsub'. Le fichier appelé doit se trouver dans le répertoire
pointé par la variable 'PROGRAM_PREFIX' ou 'SUBROUTINE_PATH' du fichier ini.
Les noms de fichiers ne peuvent inclure que des lettres *minuscules*, des
chiffres, des points et des tirets bas. Un fichier de sous-programme nommé ne peut contenir qu'une seule définition de sous-programme.

.Exemple: l'appel d'un fichier nommé
----
o<monfichier> call (appel un fichier nommé)
----

.Exemple: l'appel d'un fichier numéroté
----
o123 call (appel un fichier numéroté)
----

Dans le fichier appelé doit se touver le 'sub' et le 'endsub'
correspondant à l'appel. Le fichier doit être un fichier valide.

.Exemple: le fichier 'monfichier.ngc' appelé
----
(filename myfile.ngc)
o<myfile> sub
  (code here)
o<myfile> endsub
M2
----

[NOTE]
Les noms de fichiers doivent être en lettres minuscules, ainsi 'o<MonFichier>'
sera transformé en 'o<monfichier>' par l'interpréteur. More information about the search path and options for the
search path are in the INI Configuration Section.

== Subroutine return values(((Return Values)))

Subroutines may optionally return a value by an optional expression at
an 'endsub' or 'return' statement.

.Return value example
----
o123 return [#2 *5]
...
o123 endsub [3 * 4]
----

A subroutine return value is stored in the '#<_value>'
<<gcode:predefined-named-parameters, predefined named parameter>> , and
the '#<_value_returned>' predefined parameter is set to 1, to indicate
a value was returned. Both parameters are global, and are cleared just
before the next subroutine call.

[[ocode:errors]]
== Errors(((O-Code Errors)))

The following statements  cause an error message and  abort the
interpreter:

 - a `return` or `endsub` not within a sub definition
 - a label on `repeat` which is defined elsewhere
 - a label on `while` which is defińed elsewhere and not referring to a `do`
 - a label on `if` defined elsewhere
 - a undefined label on `else` or `elseif`
 - a label on `else`, `elseif` or `endif` not pointing to a matching `if`
 - a label on `break` or `continue` which does not point to a matching `while` or `do`
 - a label on `endrepeat` or `endwhile` no referring to a corresponding `while` or `repeat`

To make these errors non-fatal  warnings on stderr, set bit 0x20 in
the `[RS274NGC]FEATURE=` mask ini option.

// vim: set syntax=asciidoc:

:lang: fr
:toc:

[[cha:halmodule]]
= Créer des composants de l'espace utilisateur(((Creating Userspace Python Components)))

== Utilisation de base en Python

Un composant de l'espace utilisateur commence par créer ses pins et
ses paramètres, puis il entre dans une boucle dans laquelle il va
positionner périodiquement toutes ses sorties en fonction de ses
entrées. Le composant suivant, un passe-tout, copie la valeur vue sur
ses pins d'entrée ('passe_tout.in') vers ses pins de sortie ('passe_tout.out') approximativement une fois par seconde.

[source,c]
----
#!/usr/bin/env python3
import hal, time
h = hal.component("passthrough")
h.newpin("in", hal.HAL_FLOAT, hal.HAL_IN)
h.newpin("out", hal.HAL_FLOAT, hal.HAL_OUT)
h.ready()
try:
    while 1:
        time.sleep(1)
        h['out'] = h['in']
except KeyboardInterrupt:
    raise SystemExit
----

Copier le listing précédent dans un fichier nommé _passe_tout_, le
rendre exécutable par un _chmod +x_ et le placer dans son '$PATH'.On peut alors l'essayer en faisant:

----
halrun

halcmd: loadusr passthrough

halcmd: show pin

    Component Pins:
    Owner Type  Dir     Value  Name
     03   float IN          0  passthrough.in
     03   float OUT         0  passthrough.out

halcmd: setp passthrough.in 3.14

halcmd: show pin

    Component Pins:
    Owner Type  Dir     Value  Name
     03   float IN       3.14  passthrough.in
     03   float OUT      3.14  passthrough.out
----

== Composants de l'espace utilisateur et délais

Si vous tapez rapidement _show pin_, vous pourrez voir que
'passthrough.out' conserve un moment son ancienne valeur de 0. Ceci
est dû à l'appel de la fonction _time.sleep(1)_, qui fait que les pins
de sortie changent d'état, au plus, une fois par seconde.
Parce-que ce composant appartient à l'espace utilisateur,
ce délai peut apparaître plus long, par exemple si la mémoire utilisée
par le composant pass_tout est échangée avec le disque dur, le délai peut être allongé jusqu'au rafraîchissement de la mémoire.

Ces composants de l'espace utilisateur conviennent parfaitement pour des éléments tels que des panneaux de contrôle pour lesquels des délais
de l'ordre de quelques millisecondes sont imperceptibles. Ils ne
conviennent pas, en revanche, pour envoyer des impulsions de pas vers
une carte de pilotage de périphériques pour lesquelles les délais
doivent rester de l'ordre de quelques microsecondes, dans tous les cas.

== Créer les pins et les paramètres

----
h = hal.component("passe_tout")
----

Le composant lui-même est créé par l'appel du constructeur
_hal.component_. Les arguments sont le nom du composant HAL et
optionnellement, le préfixe utilisé pour les noms de pin et de paramètre.
Si le préfixe n'est pas spécifié, le nom du composant est utilisé.

----
h.newpin("in", hal.HAL_FLOAT, hal.HAL_IN)
----

Puis les pins sont créées par appels des méthodes sur l'objet
composant. Les arguments sont: pin nom suffixe, type de pin et
direction de la pin. Pour les paramètres, les arguments sont: paramètre
nom suffixe, type de paramètre et direction du paramètre.

.Noms des options de HAL
[width="95%",options="header"]
|========================================
|*Types de Pin et Paramètre:* | HAL_BIT | HAL_FLOAT | HAL_S32 | HAL_U32
|*Directions des pins:*       | HAL_IN  | HAL_OUT   | HAL_IO  |
|*Directions des paramètres:* | HAL_RO  | HAL_RW    |         |
|========================================

Le nom complet d'une pin ou d'un paramètre est formé en joignant le
préfixe avec le suffixe par un *.*, comme dans l'exemple où la pin
créée est appelée _passe_tout.in_.

----
h.ready()
----

Une fois toutes les pins et les paramètres créés, la méthode '.ready()'
est appelée.

=== Changer le préfixe

Le préfixe peut être changé en appelant la méthode _.setprefix()_. Le
préfixe courant peut être retrouvé en appelant la méthode '.getprefix()'.

== Lire et écrire les pins et les paramètres

Pour les pins et les paramètres qui sont aussi des identifiants
Python, la valeur est accessible ou ajustable en utilisant la syntaxe des attributs suivante:

----
h.out = h.in
----

Pour les pins et les paramètres qui sont aussi des identifiants
Python, la valeur est accessible ou ajustable en utilisant la syntaxe de sous-script suivante:

----
h['out'] = h['in']
----

To see all pins with their values, getpins returns all values in a dictionary
of that component.

----
h.getpins()
>>>{'in': 0.0, 'out': 0.0}
----

=== Pilotage des pins de sortie (HAL_OUT)

Périodiquement, habituellement dans le temps de réponse de l'horloge,
toutes les pins HAL_OUT doivent être _pilotées_ en leur assignant une
nouvelle valeur. Ceci doit être fait que la valeur soit différente ou
non de la valeur précédemment assignée. Quand la pin est connectée au
signal, l'ancienne valeur de sortie n'est pas copiée vers le signal, la
valeur correcte n'apparaîtra donc sur le signal qu'une fois que le composant lui aura assigné une nouvelle valeur.

=== Pilotage des pins bidirectionnelles (HAL_IO)

La règle mentionnée ci-dessus ne s'applique pas aux pins
bidirectionnelles. Au lieux de cela, une pin bidirectionnelle doit
seulement être pilotée par le composant et quand le composant souhaite
changer sa valeur. Par exemple, dans l'interface codeur, le composant
codeur positionne seulement la pin _index-enable_ à _FALSE_ quand une
impulsion d'index est vue et que l'ancienne valeur est _TRUE_, mais ne
la positionne jamais à _TRUE_. Positionner de manière répétitive la
pin à _FALSE_ pourrait faire qu'un autre composant connecté agisse comme si une nouvelle impulsion d'index avait été vue.

== Quitter

Une requête _halcmd unload_ pour le composant est délivrée comme une
exception _KeyboardInterrupt_ . Quand une requête de déchargement
arrive, le processus doit quitter
 dans un court laps de temps ou appeler la méthode _.exit()_ sur le
composant si un travail substantiel, comme la lecture ou
l'écriture de fichiers, doit être fourni pour terminer le processus d'arrêt.

== Helpful Functions

=== component_exists

Does the specified component exist at this time. +
Example:

----
hal.component_exists("testpanel")
----

=== component_is_ready

Is the specified component ready at this time. +
Example:

----
hal.component_is_ready("testpanel")
----

=== get_msg_level

Get the current Realtime msg level.

=== set_msg_level

set the current Realtime msg level. +
used for debugging information.

=== connect

Connect a pin to a signal. +
Example:

----
hal.connect("pinname","signal_name")
----

=== get_value

read a pin, param or signal directly. +
Example:

----
value = hal.get_value("iocontrol.0.emc-enable-in")
----

=== get_info_pins()

returns a list of dicts of all system pins.

[source,python]
----
listOfDicts = hal.get_info_pins()
pinName1 = listOfDicts[0].get('NAME')
pinValue1 = listOfDicts[0].get('VALUE')
pinDirection1 = listOfDicts[0].get('DIRECTION')
----

=== get_info_signals()

returns a list of dicts of all system signals.

[source,python]
----
listOfDicts = hal.get_info_signals()
signalName1 = listOfDicts[0].get('NAME')
signalValue1 = listOfDicts[0].get('VALUE')
driverPin1 = listOfDicts[0].get('DRIVER')
----

=== get_info_params()

returns a list of dicts of all system parameters.

[source,python]
----
listOfDicts = hal.get_info_params()
paramName1 = listOfDicts[0].get('NAME')
paramValue1 = listOfDicts[0].get('VALUE')
----

=== new_signal

Create a New signal of the type specified. +
Example:

----
hal.new_sig("signalname",hal.HAL_BIT)
----

=== pin_has_writer

Does the specified pin have a driving pin connected. +
Returns True or False.

----
h.in.pin_has_writer()
----

=== get_name

Get the HAL object name +
return a string

----
h.in.get_name()
----

=== get_type

Get the HAL object's type +
returns an integer

----
h.in.get_type()
----

=== get_dir

Get the HAL object direction type +
returns an integer

----
h.in.get_dir()
----

=== get

get the HAL object value

----
h.in.get()
----

=== set

set the HAL object value

----
h.out.set(10)
----

=== is_pin

Is the object a pin or parameter? +
returns bool

----
h.in.is_pin()
----

=== sampler_base

TODO

=== stream_base

TODO

=== stream

TODO

=== set_p

Set a pin value of any pin in the HAL system. +
Example:

----
hal.set_p("pinname","10")
----

== Constants

Use These To specify details rather then the value they hold.

* HAL_BIT
* HAL_FLOAT
* HAL_S32
* HAL_U32
* HAL_IN
* HAL_OUT
* HAL_RO
* HAL_RW
* MSG_NONE
* MSG_ALL
* MSG_DBG
* MSG_ERR
* MSG_INFO
* MSG_WARN

== System Information

Read these to acquire information about the realtime system.

* is_kernelspace
* is_rt
* is_sim
* is_userspace

== Use with hal_glib in GladeVCP Handler

GladeVCP uses the hal_glib library, which can be used to connect a "watcher" signal on a HAL input pin. +
This signal can be used to register a function to call when the HAL pin changes state. +

One must import the module and the hal module:

[source,python]
----
import hal_glib
import hal
----

Then make a pin and connect a 'value-changed' (the watcher) signal to a function call:

[source,python]
----
class HandlerClass:
    def __init__(self, halcomp,builder,useropts):
        self.example_trigger = hal_glib.GPin(halcomp.newpin('example-trigger', hal.HAL_BIT, hal.HAL_IN))
        self.example_trigger.connect('value-changed', self._on_example_trigger_change)
----

And have a function to be called:

[source,python]
----
    def _on_example_trigger_change(self,pin,userdata=None):
        print("pin value changed to:" % (pin.get()))
        print("pin name= %s" % (pin.get_name()))
        print("pin type= %d" % (pin.get_type()))

        # this can be called outside the function
        self.example_trigger.get()
----

== Use with hal_glib in QtVCP Handler
QtVCP uses the hal_glib library, which can be used to connect a "watcher" signal on a HAL input pin. +
This signal can be used to register a function to call when the HAL pin changes state. +

One must import the hal module:

[source,python]
----
import hal
----

Then make a pin and connect a 'value_changed' (the watcher) signal to a function call:

[source,python]
----
    ########################
    # **** INITIALIZE **** #
    ########################
    # widgets allows access to  widgets from the qtvcp files
    # at this point the widgets and hal pins are not instantiated
    def __init__(self, halcomp,widgets,paths):
        self.hal = halcomp
        self.testPin = self.hal.newpin('test-pin', hal.HAL_BIT, hal.HAL_IN)
        self.testPin.value_changed.connect(lambda s: self.setTestPin(s))
----

And have a function to be called.
This shows ways to get the pin value and information.

[source,python]
----
    #####################
    # general functions #
    #####################
    def setTestPin(self, data):
        print("Test pin value changed to:" % (data))
        print('halpin object =', self.w.sender())
        print('Halpin name: ',self.sender().text())
        print('Halpin type: ',self.sender().get_type())

        # this can be called outside the function
        print(self.testPin.get())
----

== Idées de projets

* Créer un panneau de contrôle extérieur avec boutons poussoirs,
  interrupteurs et voyants. Connecter le tout à un microcontrôleur et
  raccorder le microcontrôleur à un PC en utilisant une liaison série.
  Python est vraiment capable d'interfacer une liaison série grâce à son
  module http://pyserial.sourceforge.net/[pyserial]
  (Paquet 'python-serial', dans les dépôts universe d'Ubuntu)
* Relier un module d'affichage à LCD http://lcdproc.omnipotent.net/[LCDProc] et l'utiliser pour afficher les
  informations de votre choix (Paquet _lcdproc_, dans les dépôts
  universe d'Ubuntu)
* Créer un panneau de contrôle virtuel utilisant n'importe quelle
  librairie d'interface graphique supportée par Python (gtk, qt, wxwindows, etc)

// vim: set syntax=asciidoc:

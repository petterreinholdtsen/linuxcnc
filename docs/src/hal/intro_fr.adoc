:lang: fr
:toc:

[[cha:hal-introduction]](((HAL: Introduction)))
= Introduction à HAL

HAL(((HAL))) est le sigle de Hardware Abstraction Layer, le terme
Anglais pour Couche d'Abstraction Matériel. footnote:[Note du traducteur: nous arderons le sigle HAL dans toute la documentation.] 
Au plus haut niveau, il s'agit simplement d'une méthode pour permettre à un grand nombre de _modules_ d'être chargés et
interconnectés pour assembler un système complexe. La partie _matériel_
devient abstraite parce que HAL a été conçu à l'origine pour faciliter
la configuration de LinuxCNC pour une large gamme de matériels. Bon nombre de
ces modules sont des pilotes de périphériques. Cependant, HAL peut faire beaucoup plus que configurer les pilotes du matériel.

[[sec:hal-bases]](((HAL: Les bases)))
== HAL est basé sur le système d'étude des projets techniques

HAL est basé sur le même principe que celui utilisé pour l'étude des
circuits et des systèmes techniques, il va donc être utile d'examiner
d'abord ces principes.

N'importe quel système, y compris les machines CNC(((CNC))), est fait de composants interconnectés. Pour les machines CNC, ces composants
pourraient être le contrôleur principal, les amplis de servomoteurs, les amplis ou les commandes de puissance des moteurs pas à pas, les
moteurs, les codeurs, les contacts de fin de course, les panneaux
de boutons de commande, les manivelles électroniques, peut être aussi un variateur de
fréquence pour le moteur de broche, un automate programmable pour gérer le changeur d'outils, etc. Le constructeur de machine doit choisir les
éléments, les monter et les câbler entre eux pour obtenir un système complet et fonctionnel.

.HAL Concept - Connecting like electrical circuits.

image::images/hal_circuit_concept.png["HAL Circuit Concept",align="left"]

Figure one would be written in HAL code like this: 

----
net signal-blue    component.0.pin1-in      component.1.pin1-out
net signal-red     component.0.pin3-out     component.1.pin3-in     component.1.pin4-in
----

[[sub:hal-choix-organes(((HAL: Choix des organes)))
=== Choix des organes

Il ne sera pas nécessaire au constructeur de machine de se soucier du fonctionnement de chacun des organes, il les traitera comme des boîtes
noires. Durant la phase de conception, il décide des éléments qu'il va
utiliser, par exemple, moteurs pas à pas ou servomoteurs, quelle marque
pour les amplis de puissance, quels types d'interrupteurs de fin de
course et combien il en faudra, etc. La décision d'intégrer tel ou tel
élément spécifique plutôt qu'un autre, repose sur ce que doit faire cet
élément et sur ses caractéristiques fournies par le fabricant. La
taille des moteurs et la charge qu'ils doivent supporter affectera le
choix des interfaces de puissance nécessaires pour les piloter. Le
choix de l'ampli affectera le type des signaux de retour demandés ainsi
que le type des signaux de vitesse et de position qui doivent lui être transmis.

Dans le monde de HAL, l'intégrateur doit décider quels composants de HAL sont nécessaires. Habituellement, chaque carte d'interface
nécessite un pilote. Des composants supplémentaires peuvent être
demandés, par exemple, pour la génération logicielle des impulsions
d'avance, les fonctionnalités des automates programmables, ainsi qu'une grande variété d'autres tâches.

[[sub:hal-etude-interconnections]](((HAL: Étude des interconnexions)))
=== Étude des interconnections

Le créateur d'un système matériel, ne sélectionnera pas seulement les éléments, il devra aussi étudier comment ils doivent être
interconnectés. Chaque boîte noire dispose de bornes, deux seulement pour un simple contact, ou plusieurs douzaines pour un pilote de
servomoteur ou un automate. Elles doivent être câblées entre elles. Les
moteurs câblés à leurs interfaces de puissance, les fins de course
câblés au contrôleur et ainsi de suite. Quand le constructeur de
machine commence à travailler sur le câblage, il crée un grand plan de
câblage représentant tous les éléments de la machine ainsi que les connections qui les relient entre eux.

En utilisant HAL, les _composants_ sont interconnectés par des _signaux_ . Le concepteur peut décider quels signaux sont nécessaires
et à quoi ils doivent être connectés.

[[sub:hal-implementation]](((HAL: Implémentation)))
=== Implémentation

Une fois que le plan de câblage est complet, il est possible de
construire la machine. Les pièces sont achetées et montées, elles
peuvent alors être câblées et interconnectées selon le plan de câblage.
Dans un système physique, chaque interconnexion est un morceau de fil
qui doit être coupé et raccordé aux bornes appropriées.

HAL fournit un bon nombre d'outils d'aide à la _construction_ d'un
système HAL. Certains de ces outils permettent de _connecter_ (ou
déconnecter) un simple _fil_. D'autres permettent d'enregistrer une
liste complète des organes, du câblage et d'autres informations à
propos du système, de sorte qu'il puisse être _reconstruit_ d'une simple commande.

[[sub:hal-mise-au-point]](((HAL: Mise au point)))
=== Mise au point

Très peu de machines marchent bien dès la première fois. Lors des tests, le technicien peut utiliser un appareil de mesure pour voir si
un fin de course fonctionne correctement ou pour mesurer la tension fournie aux servomoteurs. Il peut aussi brancher un oscilloscope pour
examiner le réglage d'une interface ou pour rechercher des
interférences électriques et déterminer leurs sources. En cas de
problème, il peut s'avérer indispensable de modifier le plan de
câblage, peut être que certaines pièces devront être re-câblées
différemment, voir même remplacées par quelque chose de totalement différent.

HAL fournit les équivalents logiciels du voltmètre, de l'oscilloscope,
du générateur de signaux et les autres outils nécessaires à la mise au
point et aux réglages d'un système. Les même commandes utilisées pour
construire le système, seront utilisées pour faire les changements indispensables.

[[sub:hal-bases-resume]](((HAL: Résumé des bases)))
=== En résumé

Ce document est destiné aux personnes déjà capables de concevoir ce
type de réalisation matérielle, mais qui ne savent pas comment
connecter le matériel à LinuxCNC, par exemple pour une
<<sec:Exemple-Commande-Distante,commande distante>> telle que décrite dans la documentation de Halui.

image::images/remote-start.png[alt="Remote Start Example"]

La conception de matériel, telle que décrite précédemment, s'arrête à
l'interface de contrôle. Au delà, il y a un tas de boîtes noires,
relativement simples, reliées entre elles pour faire ce qui est
demandé. À l'intérieur, un grand mystère, c'est juste une grande boîte noire qui fonctionne, nous osons l'espérer.

HAL étend cette méthode traditionnelle de conception de matériel à
l'intérieur de la grande boîte noire. Il transforme les pilotes de
matériels et même certaines parties internes du matériel, en petites
boîtes noires pouvant être interconnectées, elles peuvent alors
remplacer le matériel externe. Il permet au _plan de câblage_ de faire
voir une partie du contrôleur interne et non plus, juste une grosse
boîte noire. Plus important encore, il permet à l'intégrateur de tester
et de modifier le contrôleur en utilisant les mêmes méthodes que celles utilisées pour le reste du matériel.

Les termes tels que moteurs, amplis et codeurs sont familiers aux
intégrateurs de machines. Quand nous parlons d'utiliser un câble extra
souple à huit conducteurs blindés pour raccorder un codeur de position
à sa carte d'entrées placée dans l'ordinateur. Le lecteur comprend
immédiatement de quoi il s'agit et se pose la question, _quel type de
connecteurs vais-je devoir monter de chaque côté de ce câble ?_ Le même
genre de réflexion est indispensable pour HAL mais le cheminement de la
pensée est différent. Au début les mots utilisés par HAL pourront
sembler un peu étranges, mais ils sont identiques au concept de travail évoluant d'une connexion à la suivante.

HAL repose sur une seule idée, l'idée d'étendre le plan de câblage à
l'intérieur du contrôleur. Si vous êtes à l'aise avec l'idée
d'interconnecter des boîtes noires matérielles, vous n'aurez sans doute
aucune difficulté à utiliser HAL pour interconnecter des boites noires logicielles.

[[sec:hal-concepts]](((HAL:Concepts)))
== Concepts de HAL

Cette section est un glossaire qui définit les termes clés de HAL mais
il est différent d'un glossaire traditionnel en ce sens que les termes
ne sont pas classés par ordre alphabétique. Ils sont classés par leur
relation ou par le sens du flux à l'intérieur de HAL.

(((HAL:Composant)))
Component:: (Composant)
Lorsque nous avons parlé de la conception du matériel, nous avons évoqué les différents éléments
individuels comme _pièces_, _modules_, _boîtes noires_, etc.
L'équivalent HAL est un _component_ ou _HAL component_. (ce document
utilisera: _HAL component_ quand la confusion avec un autre type de
composant est possible, mais normalement, utilisez juste: _component_.)
Un HAL component est une pièce logicielle avec, bien définis, des
entrées, des sorties, un comportement, qui peuvent éventuellement être interconnectés.

(((HAL:Paramètre)))
Parameter:: (Paramètre)
De nombreux composants matériels ont des réglages qui ne sont raccordés à aucun autre composant mais qui
sont accessibles. Par exemple, un ampli de servomoteur a souvent des potentiomètres de réglage et des points tests sur lesquels on peut
poser une pointe de touche de voltmètre ou une sonde d'oscilloscope
pour visualiser le résultat des réglages. Les HAL components aussi
peuvent avoir de tels éléments, ils sont appelés _parameters_. Il y a
deux types de paramètres: _Input parameters_ qui sont des équivalents
des potentiomètres. Ce sont des valeurs qui peuvent être réglées par
l'utilisateur, elles gardent leur valeur jusqu'à un nouveau réglage.
_Output parameters_ qui ne sont pas ajustables. Ils sont équivalents
aux points tests qui permettent de mesurer la valeur d'un signal interne.

(((HAL:Broche)))
Pin:: (Broche)
Les composants matériels ont des broches qui peuvent être interconnectées entre elles. L'équivalent HAL est une
_pin_ ou _HAL pin_. (_HAL pin_ est utilisé quand c'est nécessaire pour
éviter la confusion.) Toutes les HAL pins sont nommées et les noms des
pins sont utilisés lors des interconnexions entre elles. Les HAL pins
sont des entités logicielles qui n'existent qu'à l'intérieur de l'ordinateur.

(((HAL:Broche physique)))
Physical_Pin:: (Broche physique)
La plupart des interfaces d'entrées/sorties ont des broches physiques réelles pour
leur connexion avec l'extérieur, par exemple, les broches du port parallèle.
Pour éviter la confusion, elles sont appelées
_physical_pins_. Ce sont des repères pour faire penser au monde
physique réel.

Vous vous demandez peut être quelle relation il y a entre les
HAL_pins, les Physical_pins et les éléments extérieurs comme les
codeurs ou une carte stg. Nous avons ici, affaire à des interfaces de
type translation/conversion de données.

(((HAL:Signal)))
Signal::
Dans une machine physique réelle, les terminaisons
des différents organes sont reliées par des fils. L'équivalent HAL d'un
fil est un _signal_ ou _HAL signal_. Ces signaux connectent les 
_HAL pins_ entre elles comme le requiert le concepteur de la machine. 
Les _HAL signals_ peuvent être connectés et déconnectés à volonté 
(même avec la machine en marche).

(((HAL:Type)))
Type::
Quand on utilise un matériel réel, il ne viendrait pas à l'idée de connecter la sortie 24V d'un relais à l'entrée analogique
+/-10V de l'ampli d'un servomoteur. Les _HAL pins_ ont les même
restrictions, qui sont fondées sur leur type. Les _pins_ et les
_signals_ ont tous un type, un _signals_ ne peux être connecté qu'à une
_pins_ de même type. Il y a actuellement les 4 types suivants:

- bit - une simple valeur vraie ou fausse TRUE/FALSE ou ON/OFF
- float - un flottant de 32 bits, avec approximativement 24 bits de
résolution et plus de 200 bits d'échelle dynamique.
- u32 - un entier non signé de 32 bits, les valeurs légales vont de 0 à +4,294,967,295
- s32 - un entier signé de 32 bits, les valeurs légales vont 
de -2,147,483,648 à +2,147,483,647

(((HAL:Fonction)))
Function:: (Fonction)
Les composants matériels réels ont tendance à réagir immédiatement à leurs signaux d'entrée. Par exemple, si la tension d'entrée d'un ampli de servo
varie, la sortie varie aussi automatiquement. Les composants logiciels
ne peuvent pas réagir immédiatement. Chaque composant a du code
spécifique qui doit être exécuté pour faire ce que le composant est
sensé faire. Dans certains cas, ce code tourne simplement comme une
partie du composant. Cependant dans la plupart des cas, notamment dans
les composants temps réel, le code doit être exécuté selon un ordre
bien précis et à des intervalles très précis. Par exemple, les données
en entrée doivent d'abord être lues avant qu'un calcul ne puisse être
effectué sur elles et les données en sortie ne peuvent pas être écrites
tant que le calcul sur les données d'entrée n'est pas terminé. Dans ces
cas, le code est confié au système sous forme de _functions_. Chaque
_function_ est un bloc de code qui effectue une action spécifique.
L'intégrateur peut utiliser des _threads_ pour combiner des séries de
_functions_ qui seront exécutées dans un ordre particulier et selon des intervalles de temps spécifiques.

(((HAL:Fil)))
Thread:: (Fil)
Un _thread_ est une liste de _functions_ qui sont lancées à intervalles spécifiques par une tâche
temps réel. Quand un _thread_ est créé pour la première fois, il a son
cadencement spécifique (période), mais pas de _functions_. Les
_functions_ seront ajoutées au _thread_ et elle seront exécutées dans
le même ordre, chaque fois que le _tread_ tournera.

Prenons un exemple, supposons que nous avons un composant de port parallèle nommé _hal_parport_. Ce composant défini une ou plusieurs
_HAL pins_ pour chaque _physical pin_. Les _pins_ sont décrites dans ce
composant, comme expliqué dans la section _component_ de cette doc, par:
leurs noms, comment chaque _pin_ est en relation avec la _physical
pin_, est-elle inversée, peut-on changer sa polarité, etc. Mais ça ne
permet pas d'obtenir les données des _HAL pins_ aux _physical pins_. Le
code est utilisé pour faire ça, et c'est la où les _functions_ entrent
en œuvre. Le composant parport nécessite deux _functions_: une pour
lire les broches d'entrée et mettre à jour les _HAL pins_, l'autre pour
prendre les données des _HAL pins_ et les écrire sur les broches de
sortie _physical pins_. Ce deux fonctions font partie du pilote _hal_parport_.

[[sec:composants-hal]](((HAL:Composants)))
== Composants HAL

Chaque composant HAL est un morceau de logiciel avec, bien définis,
des entrées, des sorties et un comportement. Ils peuvent être installés
et interconnectés selon les besoins. Cette section liste certains des
composants actuellement disponibles et décrit brièvement ce que chacun
fait. Les détails complets sur chacun seront donnés plus loin dans ce document.

[[sub:hal-programmes-externes]](((HAL:Programmes externes)))(((HAL:Hooks)))
=== Programmes externes attachés à HAL ("hooks")

(((HAL:`motion`)))
motion::
Un module temps réel qui accepte les commandes de mouvement en NML
footnote:[Neutral Message Language provides a mechanism for handling
multiple types of messages in the same buffer as well as simplifying
the interface for encoding and decoding buffers in neutral format and
the configuration mechanism.].et inter-agit avec HAL 

(((HAL:`iocontrol`)))
iocontrol::
Un module d'espace utilisateur qui accepte les
commandes d'entrée/sortie (I/O) en NML et inter-agit avec HAL.

(((HAL:`classicladder`)))
classicladder::
Un automate programmable en langage à contacts utilisant HAL pour les entrées/sorties (I/O).

(((HAL:`halui`)))
halui::
Un espace de utilisateur de programmation qui inter-agit
avec HAL et envoie des commandes NML, Il est destiné à fonctionner
comme une interface utilisateur en utilisant les boutons et interrupteurs externes.

[[sub:hal-composants-internes]](((HAL:Composants internes)))
=== Composants internes

(((HAL:`stepgen`)))
stepgen::
Générateur d'impulsions de pas avec boucle de position. Plus de détails<<sec:Stepgen, sur stepgen>>.

(((HAL:`encoder`)))
encoder::
Codeur/compteur logiciel. Plus de détails <<sec:Codeur, sur le codeur>>.

(((HAL:`pid`)))
pid::
Boucle de contrôle Proportionnelle/Intégrale/Dérivée. Plus de détails <<sec:PID, sur le PID>>.

(((HAL:`siggen`)))
siggen::
Générateur d'ondes: sinusoïdale/cosinusoïdale/triangle/carrée,
pour la mise au point. Plus de détails <<sec:Siggen, sur siggen>>.

(((HAL:`supply`)))
supply::
Une simple alimentation, pour la mise au point

(((HAL:`blocks`)))(((HAL:`mux`)))(((HAL:`demux`)))(((HAL:`or`)))(((HAL:`and`)))(((HAL:`integ`)))(((HAL:`ddt`)))(((HAL:`limit`)))(((HAL:`wcomp`)))
blocks::
Un assortiment de composants (mux, demux, or, and, integ,
ddt, limit, wcomp, etc.).

[[sub:hal-pilotes-de-materiels]](((HAL:Pilotes de matériel)))
=== Pilotes de matériels

(((HAL:`hal-ax5214h`)))
hal_ax5214h::
Un pilote pour la carte d'entrées/sorties Axiom Measurement & Control
AX5241H.

(((HAL:`hal-gm`)))
hal_gm::
General Mechatronics GM6-PCI board.

(((HAL:`hal-m5i20`)))
hal_m5i20::
Un pilote pour la carte Mesa Electronics 5i20.

(((HAL:`hal-motenc`)))
hal_motenc::
Un pilote pour la carte Vital Systems MOTENC-100.

(((HAL:`hal-parport`)))
hal_parport::
Pilote pour le(ou les) port(s) parallèle(s). Plus de détails sur les <<cha:Parport, ports parallèles>>.

(((HAL:`hal-ppmc`)))
hal_ppmc::
Un pilote pour la famille de contrôleurs Pico Systems (PPMC, USC et UPC).

(((HAL:`hal-stg`)))
hal_stg::
Un pilote pour la carte Servo To Go (versions 1 & 2).

(((HAL:`hal-vti`)))
hal_vti::
Un pilote pour le contrôleur Vigilant Technologies PCI ENCDAC-4.

[[sub:hal-outils-utilitaires]](((HAL:Outils et utilitaires)))
=== Outils-Utilitaires

(((HAL:`halcmd`)))
halcmd::
Ligne de commande pour la configuration et les réglages. See
section <<sec:halcmd, Halcmd>>

(((HAL:`halmeter`)))
halmeter::
Un multimètre pour les signaux HAL. Plus de détails pour utiliser <<sec:Tutoriel-halmeter,halmeter>>.

(((HAL:`halscope`)))
halscope::
Un oscilloscope digital à mémoire, complétement
fonctionnel pour les signaux HAL. See the <<sec:halscope,Halscope>> section.

Chacun de ces modules est décrit en détail dans les chapitres suivants.

[[sec:hal-problemes-de-timing]](((HAL:Problèmes de timing)))
== Problèmes de timing dans HAL

Contrairement aux modèles physiques du câblage entre les boîtes noires
sur lequel, nous l'avons dit, HAL est basé, il suffit de relier deux
broches avec un signal hal, on est loin de l'action physique.

La vraie logique à relais consiste en relais connectés ensembles,
quand un relais s'ouvre ou se ferme, le courant passe (ou s'arrête)
immédiatement. D'autres bobines peuvent changer d'état etc. Dans le
style langage à contacts d'automate comme le Ladder ça ne marche pas de
cette façon. Habituellement dans un Ladder simple passe, chaque barreau
de l'échelle est évalué dans l'ordre où il se présente et seulement une
fois par passe. Un exemple parfait est un simple Ladder avec un contact
en série avec une bobine. Le contact et la bobine actionnent le même  relais.

Si c'était un relais conventionnel, dès que la bobine est sous
tension, le contact s'ouvre et coupe la bobine, le relais retombe etc.
Le relais devient un buzzer.

Avec un automate programmable, si la bobine est OFF et que le contact
est fermé quand l'automate commence à évaluer le programme, alors à la
fin de la passe, la bobine sera ON. Le fait que la bobine ouvre le
contact qui la prive de courant est ignoré jusqu'à la prochaine passe.
À la passe suivante, l'automate voit que le contact est ouvert et
désactive la bobine. Donc, le relais va battre rapidement entre on et
off à la vitesse à laquelle l'automate évalue le programme.

Dans HAL, c'est le code qui évalue. En fait, la version Ladder HAL
temps réel de Classic Ladder exporte une fonction pour faire exactement
cela. Pendant ce temps, un thread exécute les fonctions spécifiques à
intervalle régulier. Juste comme on peut choisir de régler la durée de
la boucle de programme d'un automate programmable à 10ms, ou à 1
seconde, on peut définir des _HAL threads_ avec des périodes différentes.

Ce qui distingue un thread d'un autre n'est pas ce qu'il fait mais
quelles fonctions lui sont attachées. La vraie distinction est
simplement combien de fois un thread
tourne.

Dans LinuxCNC on peut avoir un thread à 50μs et un thread à
1ms. En se basant sur les valeurs de BASE_PERIOD et de SERVO_PERIOD.
Valeurs fixées dans le fichier ini.

La prochaine étape consiste à décider de ce que chaque thread doit
faire. Certaines de ces décisions sont les mêmes dans (presque) tous
les systèmes LinuxCNC. Par exemple, le gestionnaire de mouvement est toujours ajouté au servo-thread. 

D'autres connections seront faites par l'intégrateur. Il pourrait
s'agir de brancher la lecture d'un codeur par une carte STG à un DAC
pour écrire les valeurs dans le servo thread, ou de brancher une
fonction stepgen au base-thread avec la fonction parport pour écrire les valeurs sur le port. 
